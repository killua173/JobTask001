import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, KFold, cross_val_score
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error, make_scorer
import matplotlib.pyplot as plt
import seaborn as sns



pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)


file_path = r'C:\Users\hamza\Downloads\archive (1)\global-data-on-sustainable-energy (1).csv'
data = pd.read_csv(file_path)

missing_percentage = data.isnull().sum() / len(data) * 100
print("Missing Percentage Before:")
print(missing_percentage)
print(data.dtypes)

data[r'Density\n(P/Km2)'] = pd.to_numeric(data[r'Density\n(P/Km2)'], errors='coerce')

columns_to_drop = missing_percentage[missing_percentage > 35].index
data = data.drop(columns=columns_to_drop)
print("Columns dropped due to more than 35% missing values:")
print(columns_to_drop.tolist())

plt.figure(figsize=(10, 6))
sns.boxplot(data=data)
plt.title('Box Plot for Each Column')
plt.show()

for column in data.columns:
    if data[column].isnull().sum() > 0:
        if abs(data[column].skew()) > 0.5:
            data[column].fillna(data[column].median(), inplace=True)
        else:
            data[column].fillna(data[column].mean(), inplace=True)



""" def remove_outliers(data,outlier_threshold):
    columns = data.columns[2:]
    for col in columns:
        Q1 = data[col].quantile(0.25)
        Q3 = data[col].quantile(0.75)
        IQR = Q3 - Q1
        lower_bound = Q1 - outlier_threshold * IQR
        upper_bound = Q3 + outlier_threshold * IQR
        data = data[(data[col] >= lower_bound) & (data[col] <= upper_bound)]
    return data

data_clean = remove_outliers(data,12)
 """
print("\nDataset Head:")
print(data.head())

print("\nNull Values Sum:")
print(data.isnull().sum())
summary = data.describe()
print("Summary of numerical data:")
print(summary)


target = 'Renewable-electricity-generating-capacity-per-capita'
features = [
    'Entity',
    'Energy intensity level of primary energy (MJ/$2017 PPP GDP)',
    'Electricity from renewables (TWh)',
    'Latitude',
    'Primary energy consumption per capita (kWh/person)',
    'Longitude',
    'Access to clean fuels for cooking',
    'Low-carbon electricity (% electricity)',
    'Access to electricity (% of population)',
    'gdp_per_capita',
    'Year'
]

X = data[features]
y = data[target]


X = pd.get_dummies(X, columns=['Entity'])


scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)


rf_model = RandomForestRegressor(n_estimators=100, random_state=42)


k_folds = 5

kf = KFold(n_splits=k_folds, shuffle=True, random_state=42)
mse_scorer = make_scorer(mean_squared_error, greater_is_better=False)
r2_scorer = make_scorer(r2_score, greater_is_better=True)
mae_scorer = make_scorer(mean_absolute_error, greater_is_better=False)

mse_scores = cross_val_score(rf_model, X_scaled, y, cv=kf, scoring=mse_scorer)
r2_scores = cross_val_score(rf_model, X_scaled, y, cv=kf, scoring=r2_scorer)
mae_scores = cross_val_score(rf_model, X_scaled, y, cv=kf, scoring=mae_scorer)


print(f"\nCross-validation results ({k_folds}-fold):")
print(f"Mean Squared Error: {-mse_scores.mean():.4f} (+/- {mse_scores.std() * 2:.4f})")
print(f"R-squared Score: {r2_scores.mean():.4f} (+/- {r2_scores.std() * 2:.4f})")
print(f"Mean Absolute Error: {-mae_scores.mean():.4f} (+/- {mae_scores.std() * 2:.4f})")


rf_model.fit(X_scaled, y)


""" feature_importance = pd.DataFrame({'feature': X.columns, 'importance': rf_model.feature_importances_})
feature_importance = feature_importance.sort_values('importance', ascending=False)
feature_importance['cumulative_importance'] = feature_importance['importance'].cumsum()# Separate country features from other features
country_features = feature_importance[feature_importance['feature'].str.startswith('Entity_')]
non_country_features = feature_importance[~feature_importance['feature'].str.startswith('Entity_')]

print("\nNon-country Feature Importance:")
print(non_country_features)


# Plot non-country feature importances
plt.figure(figsize=(12, 6))
sns.barplot(x='importance', y='feature', data=non_country_features.head(20))
plt.title('Top 20 Non-Country Feature Importance')
plt.tight_layout()
plt.show()

# Function to get features above a certain cumulative importance threshold
def get_features_by_cumulative_importance(importance_df, cumulative_threshold):
    return importance_df[importance_df['cumulative_importance'] <= cumulative_threshold]


for threshold in [0.8, 0.9, 0.95]:
    important_features = get_features_by_cumulative_importance(non_country_features, threshold)
    print(f"\nNon-country features accounting for {threshold*100}% of cumulative importance:")
    print(important_features)
    print(f"Number of features: {len(important_features)}")


mean_importance = non_country_features['importance'].mean()
median_importance = non_country_features['importance'].median()
print(f"\nMean non-country feature importance: {mean_importance:.4f}")
print(f"Median non-country feature importance: {median_importance:.4f}")


features_above_mean = non_country_features[non_country_features['importance'] > mean_importance]
features_above_median = non_country_features[non_country_features['importance'] > median_importance]

print(f"\nNon-country features above mean importance ({len(features_above_mean)}):")
print(features_above_mean)

print(f"\nNon-country features above median importance ({len(features_above_median)}):")
print(features_above_mean)

 """




X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)


rf_model.fit(X_train, y_train)


y_pred = rf_model.predict(X_test)


mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)


print("\nFinal Model Performance on Test Set:")
print(f"Mean Squared Error: {mse:.4f}")
print(f"R-squared Score: {r2:.4f}")
print(f"Mean Absolute Error: {mae:.4f}")



plt.figure(figsize=(10, 6))
plt.scatter(y_test, y_pred, alpha=0.5)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2)
plt.xlabel('Actual Values')
plt.ylabel('Predicted Values')
plt.title('Actual vs Predicted Values')
plt.tight_layout()
plt.show()


errors = y_test - y_pred
print("\nError Distribution:")
print(errors.describe())

plt.figure(figsize=(10, 6))
sns.histplot(errors, kde=True)
plt.title('Distribution of Errors')
plt.xlabel('Error')
plt.ylabel('Frequency')
plt.tight_layout()
plt.show()





""" 
with all features

Cross-validation results (5-fold):
Mean Squared Error: 759.2454 (+/- 332.4475)
R-squared Score: 0.9792 (+/- 0.0285)
Mean Absolute Error: 6.7815 (+/- 1.0191)




Final Model Performance on Test Set:
Mean Squared Error: 919.7541
R-squared Score: 0.9856
Mean Absolute Error: 6.4835 

"""


""" 

with 

[
    'Entity',
    'Energy intensity level of primary energy (MJ/$2017 PPP GDP)',
    'Electricity from renewables (TWh)',
    'Latitude',
    'Primary energy consumption per capita (kWh/person)',
    'Longitude',
    'Access to clean fuels for cooking',
    'Low-carbon electricity (% electricity)',
    'Access to electricity (% of population)',
    'gdp_per_capita',
    'Year'
]


Cross-validation results (5-fold):
Mean Squared Error: 638.2200 (+/- 299.2900)
R-squared Score: 0.9816 (+/- 0.0294)
Mean Absolute Error: 6.3518 (+/- 0.6557)


Final Model Performance on Test Set:
Mean Squared Error: 742.5315
R-squared Score: 0.9884
Mean Absolute Error: 6.1554 """


""" [
    'Entity',
    'Energy intensity level of primary energy (MJ/$2017 PPP GDP)',
    'Electricity from renewables (TWh)',
    'Latitude',
    'Longitude',
    'Primary energy consumption per capita (kWh/person)'
]

Cross-validation results (5-fold):
Mean Squared Error: 875.3185 (+/- 379.9036)
R-squared Score: 0.9755 (+/- 0.0353)
Mean Absolute Error: 7.7040 (+/- 1.0261)

Final Model Performance on Test Set:
Mean Squared Error: 972.4729
R-squared Score: 0.9848
Mean Absolute Error: 7.1954

 """